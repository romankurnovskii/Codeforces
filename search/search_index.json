{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Codeforces Solutions"},{"location":"#build","title":"Build","text":"<pre><code>python -m venv .venv\n. ./.venv/bin/activate\npip install -r requirements.txt\npython parse_solutions.py\n\nmkdocs serve\nmkdocs build\n</code></pre>"},{"location":"problems/1742/","title":"1742","text":"<p>Codeforces Round 827 (Div. 4)</p>"},{"location":"problems/1742/#a_sum","title":"A_Sum","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    arr = list(map(int, input().split()))\n    arr.sort()\n    if arr[0] + arr[1] == arr[2]:\n        print('YES')\n    else:\n        print('NO')\n</code></pre>"},{"location":"problems/1742/#b_increasing","title":"B_Increasing","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(\"YES\" if len(set(arr)) == n else \"NO\")\n</code></pre>"},{"location":"problems/1742/#c_stripes","title":"C_Stripes","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    input()\n    grid = [input() for _ in range(8)]\n    for row in grid:\n        if all(c == 'R' for c in row):\n            print('R')\n            break\n    else:\n        print('B')\n</code></pre>"},{"location":"problems/1742/#d_coprime","title":"D_Coprime","text":"<pre><code>import math\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    s = list(map(int, input().split()))\n    ss = [-1] * 1001\n    for i in range(n):\n        ss[s[i]] = i\n    res = -1\n    for i in range(1, 1001):\n        if ss[i] == -1:\n            continue\n        for j in range(i, 1001):\n            if ss[j] != -1 and math.gcd(i, j) == 1:\n                res = max(res, ss[i] + ss[j] + 2)\n    print(res)\n</code></pre>"},{"location":"problems/1742/#e_scuza","title":"E_Scuza","text":"<pre><code>from bisect import bisect\n\nt = int(input())\n\nfor _ in range(t):\n    n, q = map(int, input().split())\n    input_numbers = list(map(int, input().split()))\n    arr = [0] + input_numbers + [1e9 + 7]  # 1000000007\n    b = list(map(int, input().split()))\n\n    _arr = arr.copy()\n    for i in range(1, n + 2):\n        _arr[i] += _arr[i - 1]\n        arr[i] = max(arr[i], arr[i - 1])\n\n    for i in range(q):\n        b[i] = _arr[bisect(arr, b[i]) - 1]\n\n    print(' '.join(map(str, b)))\n</code></pre>"},{"location":"problems/1742/#f_smaller","title":"F_Smaller","text":"<pre><code>t = int(input())\n\n\ndef lower(x, y):\n    if any(yi &gt; 0 for yi in y[98:]):\n        return True\n\n    if x[97] &lt; y[97] and all(xi == 0 for xi in x[98:]):\n        return True\n\n    return False\n\n\nfor _ in range(t):\n    q = int(input())\n    s = [0] * 128\n    t = [0] * 128\n    s[ord('a')] = 1\n    t[ord('a')] = 1\n\n    for _ in range(q):\n        d, k, x = input().split()\n        d, k = int(d), int(k)\n\n        if d == 1:\n            for c in x:\n                s[ord(c)] += k\n        else:\n            for c in x:\n                t[ord(c)] += k\n\n        print(\"YES\" if lower(s, t) else \"NO\")\n</code></pre>"},{"location":"problems/1742/#g_orray","title":"G_Orray","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    res = []\n\n    vis = 0\n    while a:\n        # Find the index of the element with the highest bitwise AND with the complement of visited\n        idx = max(range(len(a)), key=lambda i: a[i] &amp; ~vis) \n\n        if not a[idx] &amp; ~vis:\n            break\n\n        res.append(a.pop(idx))\n        vis |= res[-1]\n\n    res.extend(a)\n\n    print(\" \".join(str(x) for x in res))\n</code></pre>"},{"location":"problems/1772/","title":"1772","text":""},{"location":"problems/1772/#a_a_b","title":"A_A_B","text":"<pre><code>def solve():\n    a, b = input().split('+')\n    res = int(a) + int(b)\n\n    print(res)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1774/","title":"1774","text":""},{"location":"problems/1774/#a_add_plus_minus_sign","title":"A_Add_Plus_Minus_Sign","text":"<pre><code>def solve():\n    n = int(input())\n    s = input()\n\n    num = int(s[0])\n    res = []\n    for i in range(1, n):\n        if num &gt; 0:\n            res.append('-')\n            num -= int(s[i])\n        else:\n            res.append('+')\n            num += int(s[i])\n    print(''.join(res))\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1774/#b_coloring","title":"B_Coloring","text":""},{"location":"problems/1774/#explanation","title":"Explanation","text":"<p>Cirno_9baka has a paper tape with n cells in a row. He wants to paint these cells with m different colors. Each color has to be used exactly $a_i$ times. </p> <p>There is a constraint that for every k consecutive cells, their colors have to be distinct. </p> <p>You have to determine if there is a way to paint the cells according to these conditions.</p> <p>Solution Logic:</p> <ol> <li>First, we need to check if the maximum possible color repetitions exceed the number of cells divided by k. If it does, there is no way to color the cells satisfying the conditions.</li> <li>If the above condition is not met, we need to check if the remaining cells after applying the most frequent color can be colored with the other colors while satisfying the k consecutive cells constraint.</li> </ol> <pre><code>from bisect import bisect_left\nfrom math import ceil\n\n\ndef solve():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n\n    max_color_repetitions = ceil(n / k)\n    most_frequent_color = a[-1]\n\n    if most_frequent_color &gt; max_color_repetitions:\n        print(\"NO\")\n        return\n\n    remaining_cells = m - bisect_left(a, most_frequent_color)\n    if most_frequent_color == max_color_repetitions and n % k and remaining_cells &gt; n % k:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1774/#c_ice_and_fire","title":"C_Ice_and_Fire","text":""},{"location":"problems/1774/#explanation_1","title":"Explanation","text":"<p>There are <code>n</code> players in a game with temperature values ranging from <code>1</code> to <code>n</code>. </p> <ul> <li>The game has <code>n-1</code> environments, each of which is either type <code>0</code> or type <code>1</code>. </li> <li>If an environment is type <code>0</code>, the player with a lower temperature value wins, and if it's type <code>1</code>, the player with a higher temperature value wins. </li> <li>The game is played in a tournament format, with players battling until only one player remains.</li> </ul> <p>For each <code>x</code> from <code>2</code> to <code>n</code>, you need to determine how many players have a chance to win if all players with temperature values not exceeding <code>x</code> participate in the game.</p> <p>Solution Logic:</p> <ol> <li>Initialize a counter and a result list.</li> <li>Loop through the range from <code>1</code> to <code>n-1</code>.</li> <li>If the current environment type is the same as the previous one, increment the counter.</li> <li>If the environment type is different, reset the counter to <code>1</code>.</li> <li>Append the current <code>index + 2 - counter</code> to the result list.</li> <li>Print the result list.</li> </ol> <pre><code>def solve():\n    n = int(input())\n    s = input()\n    counter = 1\n    res = [1]\n\n    for i in range(1, n-1):\n        if s[i] == s[i-1]:\n            counter += 1\n        else:\n            counter = 1\n        res.append(i + 2 - counter)\n\n    print(*res)\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1777/","title":"1777","text":""},{"location":"problems/1777/#a_everybody_likes_good_arrays","title":"A_Everybody_Likes_Good_Arrays","text":""},{"location":"problems/1777/#explanation","title":"Explanation","text":"<p>Optimized Solution:</p> <ol> <li>Check how many times the parity changes in the given array. </li> <li> <p>The number of operations needed is the difference between the original length of the array and the count of parity changes.</p> </li> <li> <p>Explanation</p> </li> </ol> <pre><code>def solve():\n    n = int(input())\n    ar = list(map(int, input().split()))\n\n    # Count the number of times the parity changes in the array\n    last_parity = None\n    parity_count = 0\n    for x in ar:\n        if x % 2 != last_parity:\n            parity_count += 1\n            last_parity = x % 2\n\n    # The result is the difference between the original length and the count of parity changes\n    res = n - parity_count\n    print(res)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1777/#b_emordnilap","title":"B_Emordnilap","text":""},{"location":"problems/1777/#explanation_1","title":"Explanation","text":"<p>Logic:</p> <ol> <li>Find the factorial of the given number <code>n</code></li> <li>Calculate the total number of inversion pairs in the array</li> <li>Multiply the factorial by the number of inversion pairs and take the result modulo <code>10^9 + 7</code></li> </ol> <pre><code>def solve():\n    n = int(input())\n    MOD = 10**9 + 7\n\n    # Calculate the total number of inversion pairs in the array\n    pairs = n * (n - 1)\n\n    # Find the factorial of n\n    fact = 1\n    for i in range(1, n+1):\n        fact = fact * i % MOD  # requirement: size n modulo 1000000007(109+7)\n\n    # Calculate the result by multiplying the factorial by the number of inversion pairs\n    res = (fact * pairs) % MOD\n    print(res)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1777/#c_quiz_master","title":"C_Quiz_Master","text":""},{"location":"problems/1777/#explanation_2","title":"Explanation","text":"<p>You need to form a team from a group of students with different smartness levels such that the team is proficient in all given topics. </p> <p>A student is proficient in a topic if their smartness is divisible by the topic number. </p> <p>The goal is to minimize the maximum difference in smartness between any two students in the team.</p> <p>Logic:</p> <ol> <li>Precompute divisors for all numbers up to a maximum value</li> <li>Sort the students by their smartness levels</li> <li>Use the sliding window approach with two pointers (left and right) to maintain a window of students</li> <li>Iterate through the students, updating the count of students proficient in each topic using the precomputed divisors</li> <li>Adjust the window size to minimize the maximum difference in smartness levels between any two students in the window</li> </ol> <pre><code>def solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n\n    res = float(\"inf\")\n    l = 0\n    cnt = [0] * (m + 1)\n    window = 0\n\n    for r in range(n):\n        for div in divisors[a[r]]:\n            if div &gt; m:\n                continue\n            cnt[div] += 1\n            if cnt[div] == 1:\n                window += 1\n\n        while l != n and window == m:\n            res = min(res, a[r] - a[l])\n            for div in divisors[a[l]]:\n                if div &gt; m:\n                    continue\n                cnt[div] -= 1\n                if cnt[div] == 0:\n                    window -= 1\n            l += 1\n\n    if res != float(\"inf\"):\n        print(res)\n    else:\n        print(-1)\n\n\nMAX = 100010\ndivisors = [[] for _ in range(MAX)]\nfor i in range(1, MAX):\n    for j in range(i, MAX, i):\n        divisors[j].append(i)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1777/#d_score_of_a_tree","title":"D_Score_of_a_Tree","text":""},{"location":"problems/1777/#explanation_3","title":"Explanation","text":"<p>You are given a tree with 'n' nodes, where each node has a value of either <code>0</code> or <code>1</code> at time <code>t=0</code>. </p> <p>At every subsequent time step, the value of a node becomes the bitwise XOR of the values of its children at the previous time step. </p> <p>The goal is to find the sum of the values of all nodes at every time step until <code>t=10^100</code> for all <code>2^n</code> possible initial configurations of the tree. </p> <p>The final answer should be the sum of these values <code>modulo 10^9+7</code>.</p> <p>Logic:</p> <p>The XOR operation propagates the values in the tree from the leaves towards the root. </p> <p>The maximum number of time steps required to propagate the values to the root is the depth of the tree. </p> <p>We can: 1. compute the depth of each node using depth-first search (DFS) 2. calculate the sum of the depths 3. finally multiply the sum by 2^(n-1) to account for all possible configurations.</p> <p>Naive approach:</p> <p>A naive approach would be to iterate over all possible initial configurations of <code>0s</code> and <code>1s</code> and perform the XOR operation on the tree for every time step, up to a large number (e.g., 10^100), and sum the values of all nodes.</p> <pre><code>from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef dfs(graph, depth):\n    stack = [(1, -1, True)]  # node, parent, first_visit\n    while stack:\n        node, parent, first_visit = stack.pop()\n\n        if first_visit:\n            stack.append((node, parent, False))\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    stack.append((neighbor, node, True))\n        else:  # if it's not the first visit, update the depth of the parent node\n            if parent != -1:\n                depth[parent] = max(depth[parent], depth[node] + 1)\n\ndef solve():\n    n = int(input())\n    graph = defaultdict(list)\n\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    depth = [1] * (n + 1)\n    dfs(graph, depth)\n\n    res = sum(depth[1:])  # sum of depths from the 2nd node to the last node\n    print(res * pow(2, n - 1, MOD) % MOD)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1778/","title":"1778","text":""},{"location":"problems/1778/#a_flip_flop_sum","title":"A_Flip_Flop_Sum","text":"<pre><code>def solve():\n    n = int(input())\n    ar = list(map(int, input().split()))\n    res = sum(ar)\n\n    for i in range(n-1):\n        if ar[i] == ar[i+1] == -1:\n            print(res + 4)\n            return\n    if res == n:\n        res -= 4\n    print(res)\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1787/","title":"1787","text":""},{"location":"problems/1787/#a_exponential_equation","title":"A_Exponential_Equation","text":""},{"location":"problems/1787/#explanation","title":"Explanation","text":"<p>[Explanation](https://romankurnovskii.com/en/tracks/algorithms-101/codeforces/02-combinatorics-and-geometry/1787a/</p> <pre><code>def solve():\n    n = int(input())\n    if n == 2:\n        print(1, 1)\n    elif n % 2 == 0:\n        print(1, n//2)\n    else:\n        print(-1)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1788/","title":"1788","text":""},{"location":"problems/1788/#a_one_and_two","title":"A_One_and_Two","text":"<pre><code>def solve(ar):\n    twos = ar.count(2)\n    if twos % 2 != 0:\n        return -1\n\n    passed_twos = 0\n    need_twos = twos // 2\n    for i, x in enumerate(ar):\n        if x == 2:\n            passed_twos += 1\n        if passed_twos == need_twos:\n            return i+1\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    print(solve(ar))\n</code></pre>"},{"location":"problems/1796/","title":"1796","text":""},{"location":"problems/1796/#b_asterisk_minor_template","title":"B_Asterisk_Minor_Template","text":"<pre><code>def solve():\n    a = input()\n    b = input()\n\n    if a[0] == b[0]:\n        print('YES')\n        print(f'{a[0]}*')\n    elif a[-1] == b[-1]:\n        print('YES')\n        print(f'*{a[-1]}')\n    else:\n        for i in range(len(a)-1):\n            if a[i:i+2] in b:\n                print('YES')\n                print(f'*{a[i:i+2]}*')\n                return\n        print('NO')\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1798/","title":"1798","text":""},{"location":"problems/1798/#a_showstopper","title":"A_Showstopper","text":"<pre><code>def solve(a,b,n):\n    a_max = a[0]\n\n    for i in range(n):\n        max_v = max(a[i], b[i])\n        min_v = min(a[i], b[i])\n\n        a[i] = max_v\n        b[i] = min_v\n\n        a_max = max(a_max, max_v)\n\n    if a[-1] &gt;= a_max and b[-1] &gt;= max(b):\n        return 'Yes'\n    return 'No'\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    print(solve(a, b, n))\n</code></pre>"},{"location":"problems/1799/","title":"1799","text":""},{"location":"problems/1799/#a_recent_actions","title":"A_Recent_Actions","text":""},{"location":"problems/1799/#explanation","title":"Explanation","text":"<p>Explanation</p> <pre><code>def solve():\n    n, m = list(map(int, input().split()))\n    posts = list(map(int, input().split()))\n    tracked_data = [-1] * n\n\n    last = n-1\n    used_posts = set()\n    for moment, post in enumerate(posts, 1):\n        if post not in used_posts:\n            if last &gt;= 0:\n                tracked_data[last] = moment\n                last -= 1\n                used_posts.add(post)\n    print(*tracked_data)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1807/","title":"1807","text":"<p>Codeforces Round 859 (Div. 4)</p> <p>TODO: F, G1, G2</p>"},{"location":"problems/1807/#a_plus_or_minus","title":"A_Plus_or_Minus","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    a, b, c = map(int, input().split())\n    print('+' if a + b == c else '-')\n</code></pre>"},{"location":"problems/1807/#b_grab_the_candies","title":"B_Grab_the_Candies","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    ar = list(map(int, input().split()))\n\n    m = 0\n    b = 0\n\n    if n == 1:\n        print('YES' if ar[0] % 2 == 0 else 'NO')\n    else:\n        for x in ar:\n            if x % 2 == 0:\n                m += x\n            else:\n                b += x\n        print('YES' if m &gt; b else 'NO')\n</code></pre>"},{"location":"problems/1807/#c_find_and_replace","title":"C_Find_and_Replace","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    s = input()\n\n    reserved_binaries = {}\n    binary_values = []\n\n    for c in s:\n        val = reserved_binaries.get(c, None)\n\n        if not binary_values:\n            binary_values.append(1)\n\n        if val == binary_values[-1]:\n            print('NO')\n            break\n\n        if not val:\n            val = 1 if binary_values[-1] == 0 else 0\n        reserved_binaries[c] = val\n\n        binary_values.append(val)\n    else:\n        print('YES')\n</code></pre>"},{"location":"problems/1807/#d_odd_queries","title":"D_Odd_Queries","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    n, q = map(int, input().split())\n    array = list(map(int, input().split()))\n    prefix_sum = [0] * (n + 1)\n\n    for i, a in enumerate(array):\n        prefix_sum[i + 1] = a + prefix_sum[i]\n\n    results = []\n    for _ in range(q):\n        l, r, k = map(int, input().split())\n        l -= 1\n        r -= 1\n        sum_modified = prefix_sum[l] + (r - l + 1) * k + prefix_sum[-1] - prefix_sum[r + 1]\n\n        if sum_modified % 2 == 1:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    print(\"\\n\".join(results))\n</code></pre>"},{"location":"problems/1807/#e_interview","title":"E_Interview","text":"<pre><code>t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    piles = list(map(int, input().split()))\n\n    prefix_sum = [0]\n    for pile in piles:\n        prefix_sum.append(prefix_sum[-1] + pile)\n\n    left = 1\n    right = n\n\n    # Binary search to find the pile with the special stone\n    while right &gt; left:\n        mid = (right + left) // 2\n\n        query_piles = list(range(left, mid + 1))\n\n        # Send the query and flush the output\n        print(\"?\", len(query_piles), *query_piles, flush=True)\n\n        total_weight = int(input())\n\n        # Check which half the special stone is in\n        if total_weight == prefix_sum[mid] - prefix_sum[left - 1]:\n            left = mid + 1\n        else:\n            right = mid\n\n    # Output the index of the pile with the special stone\n    print(\"!\", (left + right) // 2, flush=True)\n</code></pre>"},{"location":"problems/1807/#f_bouncy_ball","title":"F_Bouncy_Ball","text":""},{"location":"problems/1807/#g_1_subsequence_addition_easy_version","title":"G_1_Subsequence_Addition_Easy_Version","text":""},{"location":"problems/1807/#g_2_subsequence_addition_hard_version","title":"G_2_Subsequence_Addition_Hard_Version","text":""},{"location":"problems/1808/","title":"1808","text":""},{"location":"problems/1808/#a_lucky_numbers","title":"A_Lucky_Numbers","text":""},{"location":"problems/1808/#explanation","title":"Explanation","text":"<p>Hateehc is a Martian blogger who wants to buy a starship with the luckiest number. The luckiness of a number is the difference between its largest and smallest digits. </p> <p>For example, the luckiness of the number <code>142857</code> is <code>8 - 1 = 7</code>, and the luckiness of the number <code>111</code> is <code>0</code> because all its digits are the same.</p> <p>In a store, there are starships with numbers from <code>\ud835\udc59</code> to <code>\ud835\udc5f</code>. You need to help Hateehc find the starship with the luckiest number.</p> <p>Logic to solve the problem:</p> <ol> <li>Iterate through the range of starship numbers <code>[\ud835\udc59, \ud835\udc5f]</code>.</li> <li>For each number in the range, find the luckiness (the difference between the largest and smallest digits).</li> <li>Keep track of the maximum luckiness found so far and the corresponding starship number.</li> <li>Stop the iteration if the maximum luckiness is equal to 9, as this is the highest possible luckiness.</li> <li>Return the starship number with the highest luckiness.</li> </ol> <pre><code>def luck(n):\n    digits = [int(d) for d in str(n)]\n    return max(digits) - min(digits)\n\ndef solve():\n    l, r = map(int, input().split())\n    res = l\n    max_luck = luck(l)\n\n    for i in range(l + 1, min(r + 1, l + 101)):\n        curr_luck = luck(i)\n        if curr_luck &gt; max_luck:\n            max_luck = curr_luck\n            res = i\n\n        if max_luck == 9:\n            break\n\n    print(res)\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1808/#b_playing_in_a_casino","title":"B_Playing_in_a_Casino","text":""},{"location":"problems/1808/#explanation_1","title":"Explanation","text":"<p>The winnings for each game are calculated as the sum of the absolute differences between the corresponding numbers on the two players' cards.</p> <ol> <li>For each column in the grid, sort the values.</li> <li>Iterate through the sorted values and calculate the accumulated differences between each value and the previous one.</li> <li>Sum the accumulated differences for each column.</li> <li>Divide the total sum by 2 to get the total winnings.</li> </ol> <p>Calculate the total winnings for all games played in pairs. Sort the numbers in each column of the grid and calculates the accumulated differences between consecutive sorted numbers. </p> <p>The total winnings are obtained by summing up the accumulated differences and dividing the result by 2.</p> <pre><code>def solve():\n    n, m = map(int, input().split())\n    cards = [list(map(int, input().split())) for _ in range(n)]\n\n    winnings = 0\n    for j in range(m):\n        sorted_col = sorted(cards[i][j] for i in range(n))\n        accumulated_diff = 0\n        diff_sum = 0\n\n        for i in range(1, n):\n            accumulated_diff += (sorted_col[i] - sorted_col[i - 1]) * i\n            diff_sum += accumulated_diff\n\n        winnings += diff_sum\n\n    print(winnings)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1809/","title":"1809","text":"<p>Educational Codeforces Round 145 (Rated for Div. 2)</p> <p>TODO: B+</p>"},{"location":"problems/1809/#a_garland","title":"A_Garland","text":"<pre><code>def solve(s):\n    if all(c == s[0] for c in s):\n        return -1\n    elif s.count(s[0]) == 3 or s.count(s[1]) == 3:\n        return 6\n    else:\n        return 4\n\nt = int(input())\nfor _ in range(t):\n    s = input()\n    print(solve(s))\n</code></pre>"},{"location":"problems/1809/#b_points_on_plane","title":"B_Points_on_Plane","text":"<pre><code>import math\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = math.isqrt(n)\n    if a**2 == n:\n        a -= 1\n\n    print(a)\n</code></pre>"},{"location":"problems/1809/#c_sum_on_subarrays","title":"C_Sum_on_Subarrays","text":""},{"location":"problems/1809/#explanation","title":"Explanation","text":"<p>You are given two numbers, 'n' and 'k'. Your task is to create an array of length 'n' with the sum of the elements equal to 'k'. The array can contain any integer numbers, but there is a condition - the sum of any contiguous subarray should be non-positive (less than or equal to 0).</p> <p>You need to find an array that satisfies the given condition.</p> <p>Example:</p> <p>Input:</p> <p><code>n = 3, k = 5</code></p> <p>Output:</p> <p><code>[-1, 2, -6]</code></p> <pre><code>def solve(n, k):\n    res = [-1000] * n\n    if k == 0:\n        return ' '.join(map(str, res))\n\n    for i in range(n):\n        possible = (i+1) * (i+2) // 2\n        res[i] = 2\n\n        if possible == k:\n            break\n\n        if k - possible &lt;= i+1:\n            if k - possible == i+1:\n                res[i+1] = -1\n            else:\n                x = 2 * (i+1) + 1\n                x -= 2 * (k - possible)\n                res[i+1] = -x\n\n            break\n\n    return ' '.join(map(str, res))\n\n\nfor _ in range(int(input())):\n    n, k = list(map(int, input().split()))\n    print(solve(n, k))\n</code></pre>"},{"location":"problems/1809/#d_binary_string_sorting","title":"D_Binary_String_Sorting","text":""},{"location":"problems/1809/#explanation_1","title":"Explanation","text":"<p>The idea of this solution is to iterate through the binary string, tracking the counts of zeros and ones. It evaluates the cost of sorting the string by considering various operations, such as swapping consecutive elements or removing elements. </p> <p>By comparing the costs of these different operations, the solution determines the minimum number of coins required to sort the string in non-decreasing order.</p> <pre><code>def solve():\n    s = input().strip()\n    n = len(s)\n    c0 = s.count('0')\n    c1 = 0\n    res = c0 * (10**12 + 1)\n\n    for i in range(n - 1):\n        if s[i] == '1':\n            c1 += 1\n        else:\n            c0 -= 1\n\n        if s[i] == '1' and s[i + 1] == '0':\n            res = min(res, (c0 + c1 - 2) * (10**12 + 1) + 10**12)\n        else:\n            res = min(res, (c0 + c1) * (10**12 + 1))\n\n    res = min(res, s.count('1') * (10**12 + 1))\n    print(res)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1810/","title":"1810","text":"<p>CodeTON Round 4 (Div. 1 + Div. 2, Rated, Prizes!)</p>"},{"location":"problems/1810/#a_beautiful_sequence","title":"A_Beautiful_Sequence","text":"<pre><code>def solve():\n    n = int(input())\n    ar = list(map(int, input().split()))\n    for i in range(n):\n        if(ar[i] &lt;= i + 1):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1810/#b_candies","title":"B_Candies","text":""},{"location":"problems/1810/#explanation","title":"Explanation","text":"<p>The solution to this problem focuses on manipulating the number of candies by applying either the first or second spell. The idea is to check if it is possible to reach the target number of candies (n) within 40 steps. </p> <p>For each step, the algorithm determines whether it is better to use the first or the second spell based on whether the result of the spell will be closer to the target number. </p> <p>The algorithm continues applying spells and updating the number of candies until it reaches the target number or reaches the 40-step limit. </p> <p>If the target is reached, the sequence of spells is printed, otherwise, it prints -1.</p> <pre><code>def solve():\n    n = int(input())\n\n    if n % 2 == 0:\n        print(-1)\n        return\n\n    res = []\n    while n != 1:\n        if (n + 1) // 2 % 2 == 1:\n            n += 1\n            res.append(1)\n        else:\n            n -= 1\n            res.append(2)\n        n //= 2\n\n    res.reverse()\n    print(len(res))\n    print(' '.join(map(str, res)))\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1810/#c_make_it_permutation","title":"C_Make_It_Permutation","text":"<pre><code>def solve():\n    n, c, d = map(int, input().split())\n    ar = list(map(int, input().split()))\n\n    l = 0\n    r = 0\n\n    res = c * n + d\n    min_cost = 0\n\n    ar.sort()\n    if ar[0] != 1:\n        res = min(res, c * n + d)\n\n    for i in range(n):\n        r = ar[i]\n        to_remove = n - i - 1\n\n        if l == r:\n            min_cost += c\n        elif r == l + 1:\n            l = r\n            min_cost += 0\n        else:\n            min_cost += d * (max(0, r - l - 1))\n            l = r\n\n        res = min(res, min_cost + c * to_remove)\n\n    print(res)\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1810/#d_climbing_the_tree","title":"D_Climbing_the_Tree","text":""},{"location":"problems/1810/#explanation_1","title":"Explanation","text":"<ol> <li>Initialize the minimum and maximum range with the given limits.</li> <li>Iterate through each query and perform the operations.</li> <li>For type 1 operation:<ol> <li>Calculate the current minimum and maximum values using the given integers 'a', 'b', and 'n'.</li> <li>Update the overall minimum and maximum range by taking the intersection of the current range with the overall range.</li> <li>Append the result (0 or 1) based on whether the updated range is valid or not.</li> </ol> </li> <li>For type 2 operation:<ol> <li>Calculate the minimum value of 'n' that satisfies the condition based on the current range and given integers 'a' and 'b'.</li> <li>Append the result (-1 or minimum 'n').</li> </ol> </li> </ol> <pre><code>def solve():\n    min_range, max_range = 1, 10**18\n    results = []\n\n    for _ in range(int(input())):\n        operation = list(map(int, input().split()))\n\n        if operation[0] == 1:\n            a, b, n = operation[1], operation[2], operation[3]\n            curr_min = 1 if n == 1 else (a - b) * (n - 2) + a + 1\n            curr_max = (a - b) * (n - 1) + a\n\n            if curr_min &lt;= max_range and curr_max &gt;= min_range:\n                results.append(1)\n                min_range = max(min_range, curr_min)\n                max_range = min(max_range, curr_max)\n            else:\n                results.append(0)\n\n        else:\n            a, b = operation[1], operation[2]\n            min_n = max(1, (min_range - a - 1) // (a - b) + 2)\n            max_n = max(1, (max_range - a - 1) // (a - b) + 2)\n\n            if max_n &gt; min_n:\n                results.append(-1)\n            else:\n                results.append(min_n)\n\n    print(*results)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1812/","title":"1812","text":"<p>April Fools Day Contest 2023</p>"},{"location":"problems/1812/#a_are_you_a_robot","title":"A_Are_You_a_Robot","text":"<pre><code>print('security')\n</code></pre>"},{"location":"problems/1812/#b_was_it_rated","title":"B_Was_it_Rated","text":""},{"location":"problems/1812/#explanation","title":"Explanation","text":"<p>The input to the problem represents a Codeforces contest ID. Out of the first 25 Codeforces contests, the only unrated ones had IDs 15, 20, and 21.</p> <pre><code>n = int(input())\na = [15, 20, 21]\nif n in a:\n    print('NO')\nelse:\n    print('YES')\n</code></pre>"},{"location":"problems/1812/#c_digits","title":"C_Digits","text":"<pre><code>pi = '314159265358979323846264338327950288419716939937510'\n\nfor i in range(int(input())):\n    res = 1\n    for _ in range(int(pi[i])):\n        res *= int(input())\n    print(res)\n</code></pre>"},{"location":"problems/1814/","title":"1814","text":""},{"location":"problems/1814/#a_coins","title":"A_Coins","text":""},{"location":"problems/1814/#explanation","title":"Explanation","text":"<ol> <li>First, check if n is even. If it is, you can always represent n using coins of denomination <code>2 (2*x = n, and y = 0)</code>.</li> <li>If <code>n</code> is odd, then the only way to represent <code>n</code> is by using an odd number of <code>k</code> coins and an even number of 2 coins (since the sum of an odd number of odd integers and an even number of even integers is odd). In this case, check if <code>n &gt;= k</code> and <code>k</code> is odd. If so, it's possible to represent n using these coins.</li> </ol> <p>If n is even, then you can always represent n using only coins of denomination 2. If n is odd, it checks if n is greater than or equal to k and if k is odd. If this condition is satisfied, you can represent n using the given coins. Otherwise, it's not possible to represent n using the coins.</p> <pre><code>def solve():\n    n, k = map(int, input().split())\n\n    if n % 2 == 0:\n        print(\"YES\")\n    elif n &gt;= k and k % 2 == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1814/#b_long_legs","title":"B_Long_Legs","text":""},{"location":"problems/1814/#explanation_1","title":"Explanation","text":"<ol> <li>Iterate through possible leg lengths (<code>m</code>) from 1 to a large number (e.g., <code>10^5</code>).</li> <li>For each leg length <code>m</code>, calculate the number of horizontal jumps (<code>jumps_a</code>) and vertical jumps (<code>jumps_b</code>) the robot needs to reach cells <code>a</code> and <code>b</code>, respectively.</li> <li>The total moves required for each leg length <code>m</code> is the sum of <code>m</code> (number of times the robot increases its leg length), <code>jumps_a</code>, and <code>jumps_b</code>.</li> <li>Keep track of the minimum moves among all leg lengths.</li> </ol> <p>Iterates through possible leg lengths (m) and calculates the number of horizontal jumps (jumps_a) and vertical jumps (jumps_b) required to reach the target cell (a,b) for each leg length. The minimum number of moves for the robot is the sum of the leg length increases and the number of horizontal and vertical jumps. By iterating through leg lengths and keeping track of the minimum moves, the solution finds the optimal leg length and the minimum number of moves required to reach the target cell.</p> <pre><code>def solve():\n        a, b = map(int, input().split())\n        ans = float(\"inf\")\n        for m in range(1, 10**5):\n            jumps_a = (a + m - 1) // m\n            jumps_b = (b + m - 1) // m\n            ans = min(ans, jumps_a + jumps_b + m - 1)\n        print(int(ans))\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1814/#c_search_in_parallel","title":"C_Search_in_Parallel","text":""},{"location":"problems/1814/#explanation_2","title":"Explanation","text":"<p>You have n boxes with balls of different colors and two robots to retrieve balls for you. You need to assign the boxes to two lists (a and b), one for each robot. When you request a ball of color x, the robots search the boxes in their list one by one. The first robot takes s1 seconds to analyze a box, and the second robot takes s2 seconds. You have to assign the boxes to the lists in such a way that the total search time for all requests is minimized.</p> <ol> <li>Sort the boxes in decreasing order of the number of requests for their corresponding color.</li> <li>Iterate through the sorted list of boxes.</li> <li>Assign each box to the robot that will minimize the total search time.</li> <li>Print the lists a and b.</li> </ol> <pre><code>def solve():\n    n, s1, s2 = map(int, input().split())\n    R = list(map(int, input().split()))\n    S = sorted(range(n), key=lambda i: -R[i])\n\n    A, B = [], []\n    a, b = 0, 0\n    for i in S:\n        k = R[i]\n        if (a + s1) * k &lt;= (b + s2) * k:\n            A.append(i + 1)\n            a += s1\n        else:\n            B.append(i + 1)\n            b += s2\n\n    print(len(A), *A)\n    print(len(B), *B)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1816/","title":"1816","text":"<p>Codeforces Round 865 (Div. 2)</p>"},{"location":"problems/1816/#a_ian_visits_mary","title":"A_Ian_Visits_Mary","text":""},{"location":"problems/1816/#explanation","title":"Explanation","text":"<p>Ian and Mary are frogs living on a grid (Cartesian coordinate plane) with integer coordinates. Ian starts at point (0,0), and Mary is at point (a, b). </p> <p>Ian wants to reach Mary in at most two jumps. Ian can only jump from one point with integer coordinates to another point with integer coordinates without landing on any other integer-coordinate point in between.</p> <ol> <li>Ian can always reach Mary in two jumps.</li> <li>The first jump can either be to a point on the same diagonal as Mary's position or to a point with the same x or y coordinate.</li> <li>In this solution, Ian jumps to the point (a - 1, 1) if a &gt; 0 or to the point (1, 1) if a = 0. This guarantees that no other integer-coordinate points are on the line segment between the starting point and the first jump point.</li> <li>In the second jump, Ian jumps directly to Mary's position (a, b).</li> </ol> <pre><code>def solve():\n    a, b = map(int, input().split())\n    if a &gt; 0:\n        print(2)\n        print(a - 1, 1)\n        print(a, b)\n    else:\n        print(2)\n        print(1, 1)\n        print(a, b)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1816/#b_grid_reconstruction","title":"B_Grid_Reconstruction","text":""},{"location":"problems/1816/#explanation_1","title":"Explanation","text":"<ol> <li>Start by placing the maximum value (2 * \ud835\udc5b) in the top-left cell (1, 1), and the second maximum value (2 * \ud835\udc5b - 1) in the bottom-right cell (2, \ud835\udc5b).</li> <li>Fill the remaining cells in the first row and the second row using the remaining numbers in descending order while alternating rows.</li> <li>If the row has an even number of cells, start filling the row from the second cell, otherwise start from the first cell.</li> </ol> <pre><code>def solve():\n    n = int(input())\n    grid = [[None] * n for _ in range(2)]\n    grid[0][0] = n * 2\n    grid[-1][-1] = n * 2 - 1\n\n    for i in range(2):\n        tmp1 = n * 2 - 2 - i % 2\n        tmp2 = (i + 1) % 2 + 1\n\n        for j in range(n):\n            if grid[i][j] is None:\n                if (i + j) % 2:\n                    grid[i][j] = tmp2\n                    tmp2 += 2\n                else:\n                    grid[i][j] = tmp1\n                    tmp1 -= 2\n\n    for line in grid:\n        print(*line)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1816/#c_ian_and_array_sorting","title":"C_Ian_and_Array_Sorting","text":""},{"location":"problems/1816/#explanation_2","title":"Explanation","text":"<p>The main idea of the solution is to iterate through the array, making the difference between consecutive pairs alternate between positive and negative. To do this, we can perform the following algorithm:</p> <ol> <li>Iterate through the array with a step of 2 (i.e., process every other element).</li> <li>For each element, check if it is the last element or the second-last element.</li> <li>If it's the last element, the answer is \"YES\" because we can always make the array non-decreasing by adding or subtracting the same value from every other element.</li> <li>If it's the second-last element, the answer is \"YES\" if the current element is less than or equal to the next element, otherwise, it's \"NO\".</li> <li>If the current element is not the last or second-last element, update the next next element by subtracting the difference between the current element and the next element. This ensures that the difference between consecutive pairs alternates between positive and negative.</li> </ol> <pre><code>def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    for i in range(0, n, 2):\n        if i == n - 1:\n            print(\"YES\")\n            return\n        if i == n - 2:\n            if a[i] &lt;= a[i + 1]:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n            return\n\n        a[i + 2] -= a[i + 1] - a[i]\n\n    print(\"YES\")\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1821/","title":"1821","text":""},{"location":"problems/1821/#a_matching","title":"A_Matching","text":""},{"location":"problems/1821/#explanation","title":"Explanation","text":"<p>Logic:</p> <p>For a given integer template, the number of integers that match the template depends on the number of question marks and their positions. </p> <p>For the first position, if it's a question mark, you can use any digit from 1 to 9; for other positions, if it's a question mark, you can use any digit from 0 to 9.</p> <p>Approach:</p> <p>Iterate through the given string, checking each character. If the first character is '0', set the result to 0. If the character is a question mark, multiply the result by 9 if it's the first position, otherwise multiply by 10.</p> <pre><code>def solve():\n    s = input().strip()\n\n    if s[0] == '0':\n        print(0)\n        return\n\n    res = 1\n    for i, char in enumerate(s):\n        if char == '?':\n            res *= 9 if i == 0 else 10\n\n    print(res)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1821/#b_sort_the_subarray","title":"B_Sort_the_Subarray","text":""},{"location":"problems/1821/#explanation_1","title":"Explanation","text":"<p>Find two integers <code>l</code> and <code>r (1\u2264\ud835\udc59\u2264\ud835\udc5f\u2264\ud835\udc5b)</code>, such that sorting the subarray <code>a[l..r]</code> of the given array <code>a</code> would result in the given array <code>a</code>. If there are multiple answers, choose the one with the longest subarray. If there are still multiple answers, any of them is acceptable.</p> <pre><code>def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    l, r = 0, n - 1\n\n    while a[l] == b[l]:\n        l += 1\n\n    while a[r] == b[r]:\n        r -= 1\n\n    while r &lt; n - 1 and b[r] &lt;= b[r + 1]:\n        r += 1\n\n    while l &gt; 0 and b[l - 1] &lt;= b[l]:\n        l -= 1\n\n    print(l + 1, r + 1)\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"},{"location":"problems/1821/#c_tear_it_apart","title":"C_Tear_It_Apart","text":""},{"location":"problems/1821/#explanation_2","title":"Explanation","text":"<ol> <li>Iterate through all lowercase Latin letters (26 iterations).</li> <li>For each letter, split the input string <code>s</code> into substrings, using the current letter as the delimiter.</li> <li>For each substring created in step 2, calculate the minimum number of operations required to make all the letters in the substring the same. This is done by finding the length of the substring and calculating the smallest power of 2 that is greater than or equal to that length. The number of operations required is the exponent of that power of 2.</li> <li>Keep track of the maximum number of operations required among all the substrings for the current letter.</li> <li>After iterating through all the letters, find the minimum number of operations among all the maximums calculated in step 4. This minimum will be the answer to the problem.</li> </ol> <pre><code>def solve():\n    s = input()\n    min_operations = float('inf')\n\n    for i in range(26):\n        current_char = chr(97 + i)\n        substrings = s.split(current_char)\n\n        max_operations_for_char = 0\n        for substring in substrings:\n            length = len(substring)\n            operations = 0\n\n            # smallest power of 2 that is greater than or equal to the len of substr\n            while length &gt; 0:\n                length //= 2\n                operations += 1\n\n            max_operations_for_char = max(max_operations_for_char, operations)\n\n        min_operations = min(min_operations, max_operations_for_char)\n\n    print(min_operations)\n\n\nfor _ in range(int(input())):\n    solve()\n</code></pre>"}]}